## 判断公共祖先
1. lc235:判断BST中结点p和q的最近公共祖先
- 理解难点：BST中公共祖先root的定义？
根据BST的特性，若root是p/q的公共祖先，
    -如果 root!=p&&root!=q，那么p/q必定在root的不同子树上，因此一定不满足p/q的val同时大于或小于root的值
    -如果 root==p||root==q，这种情况的规定是，一个节点也可以是它自己的祖先，p/q自己就是公共祖先
- 思路：
-> 比较pq的值和root的值，判断pq在哪个子树上
-> 如果pq在不同子树or直接等于root的值，说明找到了公共祖先，直接返回root
- 为什么最先递归到的，使p/q在不同子树上的root必定就是最近的公共祖先？
倒推：如果root不是最近公共祖先，root的子树中还存在比root更近的公共祖先
    - 那么pq必须在root的子树上，pq的值必须同时大于or小于root的值
    - 和"p/q必定在root的不同子树上，因此一定不满足p/q的val同时大于或小于root的值"的条件矛盾
    - 结论：最先递归到的，使p/q在不同子树上的root，必定就是最近的公共祖先！！

## 树的最大深度
1. lc543：计算树的直径
- 思考：如果能找到和原问题相似的子问题，并且建立起他们之间的联系，就能够用递归解决
- 二叉树的左右子树本身就和整个树是相似的，天然就有递归性
- 思路：
->什么叫直径：任意两个叶子节点之间的最长路径（注意：不一定非要经过root节点）
->要记录以任意一个节点为根的直径情况，并且比较，最后得出最大值
->怎么求任意一个节点的直径：直径=左子树高度+右子树高度
->怎么求子树的高度？经典向下递归：Math.max(leftHeight, rightHeight) + 1;
-> 分别递归左右子树，return子树的高度，然后计算两者的和，用一个变量储存并且不断更新最大值

